# Advent of Code 2022
This was the first AoC I ever completed, and I decided to do it in Rust, which I had very little
experience with. It was a bad idea and a good idea at the same time.

I'm not going to go explain every detail of every solution. All I will say is that they finish in
reasonable time, and that most solutions should work with any valid input. I didn't try to get a
position on the leaderboards, either. Mostly because the puzzles come out at 6 AM and I'm not going
to let a puzzle ruin my sleep quality. It's also because I used a rather unfamiliar language.

# AoC '22 thoughts
Almost only positive. The earlier puzzles were too easy, but how else can you lower the entry skill
requirement? I had to wait until around day 11 for more challenging puzzles. Some of them even had
me so stumped that I had to learn new techniques to solve them. Learning is the fun part, so I will
list the puzzles that I got stuck on and how I broke through:
* Day 16 (Proboscidea Volcanium): The search space was huge, but the graph contained many broken
  and redundant valves, so I removed them and joined their neighbors together. Evaluating all n! 
  possible paths through the graph was also quite expensive, so I slapped on some memoization and
  moved on.
* Day 17 (Pyroclastic Flow): First time I had to exploit a pattern to avoid repeating the same
  computations a billion times. Honestly, I don't think my pattern recognition works for all
  inputs, one example is if the rock polyominoes weave between the other fallen pieces. I don't
  think this happens in any of the possible inputs provided by AoC, but I still prefer to solve
  these problems in the general case. If someone knows a general solution, please let me know about
  it.
* Day 19 (Not Enough Minerals): Perhaps the biggest search space of all puzzles this year. It was
  too hard for me to solve on my own, so I consulted some existing solutions. Here's what I
  learned:
    * Many states have different properties but are functionally the same. For instance, if the
      most expensive robot costs 5 ore, why have more than 5 ore robots? You simply can't spend
      more ore per minute than the most expensive ore cost. This principle can then be applied to
      all robot types.
    * Similar to the above, if you already have a surplus of minerals, you may not be able to spend
      all of it before the time ends. You can simply throw away the minerals that you don't have
      enough time to spend.
    * Perhaps most importantly, if you can find a solution with many geodes and not necessarily the
      most geodes possible, you can prune a lot of states which simply cannot reach that number.
      Such states are useless and will not become the best solution.
        * To help find a high geode count, I used a mix of BFS and DFS: If you can produce a new
        geode robot right now, push the new state to the front of the queue instead of the back.
        Now you'll start making solutions with more geodes sooner than usual.
* Day 22 (Monkey Map): Looks a lot of people got stuck on part 2. You have to **fold the map into a
  cube**. This was absolute insanity at first glance. But then people started hard-coding all of
  the cube folds, because the inputs generated by AoC were always the same [net](https://en.wikipedia.org/wiki/Net_(polyhedron))
  of the cube. However, since I wasn't going for the leaderboard, I stubbornly wrote an algorithm
  to fold the cube anyway:
    * I defined rules for what happens when you cross the border of a face: which face
      you'll end up on, and which side of that face you'll be entering. This is easy to work out
      for faces that are adjacent on the net, but less obvious for non-adjacent ones.
    * To link the non-adjacent faces, I would find faces that share the same neighbor but are not
      neighbors with each other. Based on the relationship between those two faces and their common
      neighbor, I could determine which sides of the two faces would link up.
    * Finally, when moving along the surface of the cube, I would track the current position
      relative to the current cube face, and when you walk off that face, update the position
      and facing according to which side of the new face you end up on.
    * Does this work for any cube? Probably. Did I test all 11 nets of the cube and their symmetric
      variants? No... but I'm still proud of my work. After all, how do I test that the algorithm is
      correct? How does [Eric Wastl](https://adventofcode.com/2022/about) test if his algorithms
      are correct? I can't be bothered to answer such paradoxes.
* Day 24 (Blizzard Basin): Holy mother of optimizations. Part of me thinks I overengineered my
  solution, but I'm simply too exhausted to find out. This puzzle brought out much of what I
  learned from day 19, so I was able to solve this one on my own. The foundation of my solution is
  a basic pathfinding algorithm which puts its states on a priority queue which sorts the states by
  shortest theoretical path. To make the algorithm reasonably fast, I made the following
  optimizations:
    * Store vertical and horizontal blizzards in separate hash maps and evaluate all possible
      positions for those maps. Since the grid is a rectangle, the horizontal and vertical
      blizzards move on two separate cycles determined by the dimensions of the rectangle. In my
      case, the horizontal blizzards repeat after 120 minutes and the vertical blizzards after 25.
      I stored them in hash maps to reduce lookup time and to know whether 2 blizzards overlap or
      not. If I had used a hash set, then 2 blizzards would turn into 1 when they overlap.
    * Memoize already visited positions. Actually, you have to memoize the position and time, since
      the positions of the blizzards depends on the time. This is a 3D path search in disguise.
      Though, I did learn that my algorithm sometimes finds shorter paths to an already visited
      position, so I implemented the memoization as a hash map that maps position and time to how
      long it took to reach said position.
        * Since the blizzards move on a cycle, you can take the time as the remainder of the actual
        time divided by the [LCM](https://en.wikipedia.org/wiki/Least_common_multiple) of the
        horizontal and vertical blizzard cycles. The LCM gives us how much time it takes for all
        blizzards to repeat themselves.
        * Note that part 2 has you move back and forth between the start and end points, so you
        have to memoize the number of trips you've made as well.
    * Similarly to day 19, I prune states which cannot theoretically find a path shorter than the
      already shortest found path.
    * To reinforce the above point, I implemented a greedy search algorithm that would find a short
      path, but not the shortest. The algorithm is a backtracking search algorithm which prefers
      moving right and down over waiting, and waiting over moving left or up. This priority flips
      when traversing the grid in reverse. If the algorithm can't move, it backtracks. Once a solution is found, the path length is immediately
      returned without considering any alternatives.
        * That sounded silly, but it seriously made a huge difference in execution time, since it
        completely eliminates solutions which sit around and accomplish nothing. You could simply
        guess and assume that there exists a path of, say, 1000 minutes, but making such a guess
        risks pruning the shortest path during the actual search.

I have also learned to code fewer bugs, but you don't wanna hear about that.

# Rust thoughts
Iterators. Iterators, everywhere. It's oddly fun to solve a problem using functional paradigms, and
Rust's iterators are how you do that. Though I stopped using them after reaching a certain point in
AoC, because the procedural version of the same code would be much easier to understand. But it's
nice to know that there is a good mix of functional and procedural programming in Rust.

I don't know why it took me so long to understand the borrow checker thing. I've tried Rust before,
and just never understood how to fix those errors, but after reading the Rust book one more time,
it really isn't that complicated. We take for granted that any data can be copied, but should they
be? After all, copying a reference to some data does not mean that the reference will always be
valid. This fundamental idea has helped me understand why the compiler rejects so much code. It's
there to help you, not bother you with endless nagging.

Now, I'm sure there is lots to Rust's design that I won't like. I just haven't found them yet. Or
maybe they don't exist. Perhaps.

Gosh, I'm starting to sound like those Rust preachers. Was Rust this good all long? Do we hate
languages because it's cool? Do we secretly love C++?

# Usage
Did you read all that rabble up there? No? Alright, just cheat and get all your AoC answers then:
```sh
cargo run --release <all|1-25> [repeat_count]
```

Input files go in the `input/` directory at the root of the repository and are named `day1`, `day2`, ..., `day25` without file
extension.
